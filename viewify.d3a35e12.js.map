{"mappings":"A,S,qB,C,C,C,E,C,A,M,G,E,E,M,A,G,C,E,E,M,A,E,I,I,E,E,E,A,M,G,E,E,I,C,C,E,C,C,C,E,C,O,C,C,S,kB,C,E,G,M,O,C,G,O,C,C,S,qB,C,E,G,M,O,C,G,O,qB,E,C,S,mB,C,C,C,C,C,C,C,C,C,C,C,C,C,E,G,C,I,E,C,C,E,C,G,E,E,K,A,C,M,E,C,E,G,M,C,E,I,C,E,G,Q,O,C,G,I,C,E,E,C,S,oB,C,E,O,W,I,E,I,C,E,U,O,I,Q,S,C,C,C,E,I,E,E,K,C,E,G,S,E,C,E,mB,E,E,E,E,E,O,E,C,S,E,C,E,mB,E,E,E,E,E,Q,E,C,E,K,E,E,C,C,S,iB,C,C,C,C,C,E,O,K,E,O,c,C,E,E,C,M,E,W,C,E,a,C,E,S,C,C,G,C,C,E,C,E,C,C,S,mB,C,E,G,A,a,O,Q,A,M,C,C,O,Q,C,E,A,M,C,C,a,C,O,M,I,C,E,C,S,yB,C,C,C,E,I,E,E,E,A,M,E,K,A,a,O,Q,C,C,O,Q,C,E,C,C,a,C,G,A,M,G,I,E,E,C,E,C,E,E,C,E,G,C,I,E,E,I,C,G,C,C,E,A,C,E,E,I,E,E,I,A,I,E,I,C,E,K,E,C,G,E,M,G,G,E,C,G,C,M,E,C,E,C,E,E,C,Q,C,G,C,A,G,A,M,E,M,E,E,M,E,Q,C,G,E,M,C,C,C,O,E,C,S,qB,M,A,U,6I,C,S,uB,M,A,U,wI,C,S,e,C,E,I,I,E,E,E,U,M,C,I,C,I,E,A,M,S,C,E,C,S,C,E,C,C,E,E,O,I,C,E,A,C,Y,O,O,qB,E,C,E,E,M,C,O,qB,C,G,M,C,S,C,E,O,O,wB,C,E,G,U,A,G,E,E,O,C,S,C,E,iB,E,E,C,C,E,C,E,C,O,C,C,S,Q,C,C,C,E,I,E,O,I,C,G,G,O,qB,C,C,I,E,O,qB,C,E,C,G,C,E,E,M,C,S,C,E,O,O,wB,C,E,G,U,A,E,E,E,I,C,K,C,E,E,C,O,C,C,S,qB,C,C,C,E,O,E,A,M,E,E,C,E,O,yB,C,O,gB,C,E,O,yB,C,I,Q,O,I,O,C,S,C,E,O,c,C,E,E,O,wB,C,E,G,G,C,C,S,iB,C,C,C,E,O,kB,I,yB,E,I,+B,E,I,oB,C,S,qB,C,E,O,qB,I,mB,I,+B,I,sB,C,S,+B,C,C,C,E,G,G,G,A,U,O,E,O,qB,E,G,I,E,O,S,C,Q,C,I,C,G,K,C,E,I,G,A,W,G,E,W,E,C,E,E,W,C,I,A,E,A,Q,G,A,Q,E,O,M,I,C,G,G,A,c,G,2C,I,C,G,O,qB,E,G,C,S,c,C,C,C,E,I,E,E,E,E,C,M,E,K,W,G,A,E,C,C,E,C,M,C,C,E,C,O,C,C,E,A,E,K,E,C,I,E,A,E,E,O,M,C,A,C,A,Y,O,S,S,M,E,S,E,O,E,I,C,E,G,E,K,C,E,G,E,M,C,E,G,A,Y,O,Q,C,C,C,O,Q,C,C,W,O,I,A,C,E,E,S,E,C,E,O,S,C,M,E,C,E,E,C,G,E,M,A,U,mC,K,G,C,E,E,C,C,E,E,C,E,C,C,E,G,G,C,G,E,E,G,C,E,A,E,C,C,E,C,E,M,C,C,C,E,C,E,K,E,C,A,C,E,E,M,A,G,E,I,C,G,C,E,E,I,A,G,C,A,C,E,E,I,C,E,C,C,E,C,E,I,C,O,E,O,E,E,A,G,C,E,C,A,E,C,C,E,C,E,K,C,A,E,C,C,E,E,K,E,K,E,E,E,K,M,E,O,E,K,G,C,M,C,C,E,C,K,C,C,C,M,E,E,K,G,E,C,C,E,C,E,C,E,C,Q,M,E,E,E,G,C,G,G,E,I,C,G,G,Q,S,G,C,C,E,A,C,E,E,I,A,E,M,C,G,C,C,E,M,C,E,A,G,C,A,I,C,C,E,E,A,I,C,C,E,A,E,C,E,E,Q,C,G,A,I,C,C,E,E,C,C,G,C,C,E,C,C,C,E,E,C,C,E,C,C,C,E,A,E,C,E,K,C,C,C,E,C,K,C,G,A,I,C,C,E,E,E,K,C,C,C,E,C,C,E,K,C,C,C,E,C,E,E,K,C,G,G,E,K,C,C,C,E,C,C,E,K,C,C,C,E,C,E,G,C,I,C,G,K,C,C,C,E,E,E,G,C,G,G,E,I,C,G,G,Q,C,E,E,I,C,E,E,C,M,E,C,E,C,E,E,C,E,C,Q,C,E,E,C,C,G,A,E,C,C,E,C,M,C,C,E,C,M,C,M,C,C,E,C,C,C,E,C,K,E,K,C,C,C,C,C,CCSA,IATI,YACA,SACA,SACA,UACA,cACA,SACA,WACA,OACA,kBAEA,iBAiFA,cAlFA,OAAS,CAAA,EAGP,UAAY,IAAI,gBAAgB,OAAO,QAAQ,CAAC,MAAM,EACtD,KAAO,UAAU,GAAG,CAAC,QAErB,SAAW,mCACX,YAAc,sCAEhB,CAAC,UACH,QAAQ,IAAI,CAAC,iFAGf,IAAM,SAAW,SAAO,CAAxB,E,O,oB,WAEU,IAAA,EAmBA,EACA,EAkBC,E,O,c,I,C,S,C,E,O,E,K,E,K,EArCP,G,E,I,C,I,C,C,E,G,E,EAAI,CADE,CAAA,EAAe,aAAa,OAAO,CAAC,gBAApC,EACa,MAAM,AAAI,MAAM,2CAkBvB,MAAA,C,EAAM,MAhBN,yCACI,CACd,OAAQ,OACR,QAAS,CACP,eAAgB,oCAChB,OAAU,kBACZ,EACA,KAAM,IAAI,gBAAgB,CACxB,UAAW,SACX,WAAY,qBACZ,KAAA,EACA,aAAc,YACd,cAAe,CACjB,EACF,G,A,M,EAGiB,MAAA,C,EAAM,AADjB,CAAA,EAAM,EAAN,IAAA,EAAA,EACqB,IAAI,G,A,M,EAG/B,GAFA,QAAQ,GAAG,CAAC,2BADN,EAAW,EAAX,IAAA,IAGF,CAAC,EAAI,EAAE,CACT,MAAM,AAAI,MAAM,CAAC,wBAAwB,EAAE,EAAI,MAAM,CAAC,EAAE,EAAE,KAAK,SAAS,CAAC,GAAA,CAAW,EAGtF,GAAI,CAAC,EAAS,YAAY,CACxB,MAAM,AAAI,MAAM,CAAC,mCAAmC,EAAE,KAAK,SAAS,CAAC,GAAA,CAAW,EASlF,OANA,aAAa,OAAO,CAAC,eAAgB,EAAS,YAAY,EACtD,EAAS,aAAa,EAAE,aAAa,OAAO,CAAC,gBAAiB,EAAS,aAAa,EAExF,OAAO,OAAO,CAAC,YAAY,CAAC,CAAC,EAAG,SAAS,KAAK,CAAE,OAAO,QAAQ,CAAC,QAAQ,EAExE,QAAQ,GAAG,CAAC,uCACZ,C,EAAO,EAAS,YAAY,C,A,M,EAE5B,QAAQ,KAAK,CAAC,kBADP,EAAA,EAAA,IAAA,IAIP,GAAI,CACF,OAAO,OAAO,CAAC,YAAY,CAAC,CAAC,EAAG,SAAS,KAAK,CAAE,OAAO,QAAQ,CAAC,QAAQ,CAC1E,CAAE,MAAO,EAAG,CACV,QAAQ,IAAI,CAAC,uBAAwB,EACvC,CAIA,GAAI,GAAO,EAAI,OAAO,EAAI,EAAI,OAAO,CAAC,QAAQ,CAAC,iBAAkB,CAC/D,QAAQ,IAAI,CAAC,6DACb,GAAI,CAAE,MAAQ,CAAE,MAAO,EAAG,CAAE,QAAQ,KAAK,CAAC,0BAA2B,EAAI,CACzE,MAAA,C,EAAQ,AACV,CAGA,MAAM,C,M,E,M,C,E,A,C,EAEV,I,EAEA,SAAe,mB,O,oB,W,O,c,I,C,S,C,EACb,MAAA,C,EAAO,aAAa,wC,A,EACtB,I,CAKA,SAAS,YACL,QAAQ,GAAG,CAAC,gBACZ,mBACG,IAAI,CAAC,SAAA,CADR,EAEI,QAAQ,GAAG,CAAC,GACR,EAAO,IAAI,EAEf,YAAc,EAAO,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,EAAE,CAAC,GAAG,CAC7C,SAAS,cAAc,CAAC,OAAO,GAAG,CAAG,YAErC,SAAW,EAAO,WAAW,CAC7B,kBAAoB,KAAK,GAAG,GAE5B,UAAY,AADZ,CAAA,SAAW,EAAO,IAAI,CAAC,WAAW,AAAX,EACA,SACvB,aAAa,eACb,cAAgB,WAAW,UAAU,UAAU,GAE/C,cAAgB,EAAO,IAAI,CAAC,EAAE,CAE9B,WAAa,EAAO,IAAI,CAAC,IAAI,CAC7B,SAAS,cAAc,CAAC,aAAa,SAAS,CAAG,WAE7C,EAAO,OAAO,CAAC,SAAS,CAAC,OAAO,EAAI,CAAC,SACvC,SAAS,cAAc,CAAC,QAAQ,SAAS,CAAG,4DAC5C,SAAS,cAAc,CAAC,QAAQ,OAAO,CAAG,OAC1C,OAAS,CAAA,GAEP,EAAO,OAAO,CAAC,SAAS,CAAC,QAAQ,EAAI,SACvC,SAAS,cAAc,CAAC,QAAQ,SAAS,CAAG,uDAC5C,SAAS,cAAc,CAAC,QAAQ,OAAO,CAAG,MAC1C,OAAS,CAAA,GAGX,UAAU,EAAO,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,IAAI,CAAE,WAAY,EAAO,IAAI,CAAC,KAAK,CAAC,IAAI,CAAE,KAAK,KAAK,CAAC,SAAS,MAC5F,IAAI,CAAE,SAAA,CADT,EAGI,GAAI,CAAC,GAAgB,AAAwB,IAAxB,EAAa,MAAM,CAAQ,CAC9C,SAAS,cAAc,CAAC,aAAa,SAAS,CAAG,6BACjD,OAAS,EAAE,CACX,MACF,CAGA,OAAS,EAAa,KAAK,CAAC,MAAM,GAAG,CAAC,SAAA,CAAtC,EACE,IAAM,EAAQ,EAAK,KAAK,CAAC,sCACzB,AAAK,EAIE,CAAE,KADI,AAAU,GAFP,SAAS,CAAK,CAAC,EAAE,CAAE,IACnB,WAAW,CAAK,CAAC,EAAE,EAEpB,KAAM,CAAK,CAAC,EAAE,AAAC,EAJX,IAKrB,GAAG,MAAM,CAAC,SAGV,IAAM,EAAiB,SAAS,cAAc,CAAC,YAC/C,CAAA,EAAe,SAAS,CAAG,GAC3B,OAAO,OAAO,CAAC,SAAC,CAAA,CAAO,CAAvB,EACE,IAAM,EAAI,SAAS,aAAa,CAAC,KACjC,EAAE,SAAS,CAAC,GAAG,CAAC,QAChB,EAAE,WAAW,CAAG,EAAM,IAAI,EAAI,GAC9B,EAAe,WAAW,CAAC,GAC3B,EAAM,EAAE,CAAG,CACb,GACA,EAAe,SAAS,CAAG,EAC3B,gBAEF,KAEA,SAAS,cAAc,CAAC,OAAO,GAAG,CAAG,uBACrC,SAAS,cAAc,CAAC,aAAa,SAAS,CAAG,kBAErD,GACC,KAAK,CAAC,SAAA,CADP,EACc,OAAA,QAAQ,KAAK,CAAC,E,EAClC,CAGA,SAAS,iBACP,YAAY,WACV,GAAI,AAAC,QAAU,AAAkB,IAAlB,OAAO,MAAM,GAAU,QAMtC,IAAK,IAJC,EAAc,KAAK,KAAK,CAAE,AAAA,CAAA,SAAY,CAAA,KAAK,GAAG,GAAK,iBAAA,CAAgB,EAAI,KAGzE,EAAc,GACT,EAAI,EAAG,EAAI,OAAO,MAAM,CAAE,IACjC,GAAI,GAAe,MAAM,CAAC,EAAE,CAAC,IAAI,CAC/B,EAAc,OAEd,MAKR,OAAO,OAAO,CAAC,SAAC,CAAA,CAAO,CAAvB,EACE,EAAM,EAAE,CAAC,SAAS,CAAC,MAAM,CAAC,SAAU,SAEhC,IAAM,EACR,EAAM,EAAE,CAAC,SAAS,CAAC,GAAG,CAAC,UACd,CAAA,IAAM,EAAc,GAAK,IAAM,EAAc,CAAA,GACtD,EAAM,EAAE,CAAC,SAAS,CAAC,GAAG,CAAC,QAE3B,GAGwB,KAAhB,GAEF,AADiB,MAAM,CAAC,EAAY,CAAC,EAAE,CAC9B,cAAc,CAAC,CACtB,SAAU,SACV,MAAO,QACT,GAEJ,EAAG,GACL,CAGA,SAAe,iB,O,oB,W,O,c,I,C,S,C,E,O,E,K,E,K,EACX,MAAA,C,EAAM,mBAAmB,IAAI,CAAC,SAAA,CAAxB,MAEiB,EADnB,SAAW,EAAO,IAAI,CAAC,EAAE,CACzB,iBAAmB,MAAA,CAAA,EAAA,EAAO,OAAO,CAAC,SAAS,CAAC,OAAO,AAAP,GAAzB,CACvB,G,A,M,E,OAHA,EAAA,IAAA,GAIA,QAAQ,GAAG,CAAC,qBACR,CAAA,UAAY,eAAiB,QAAU,gBAAA,GACvC,YAEJ,WAAW,eAAe,K,C,E,A,C,EAC9B,I,CAEA,SAAe,UAAU,CAAM,CAAE,CAAI,CAAE,CAAK,CAAE,CAAQ,E,O,oB,WAC9C,IAAA,EAEE,EAKA,E,O,c,I,C,S,C,E,O,E,K,E,K,EAPF,EAAM,CAAC,uCAAuC,EAAE,mBAAmB,GAAQ,YAAY,EAAE,mBAAmB,GAAM,YAAY,EAAE,mBAAmB,GAAO,UAAU,EAAE,EAAA,CAAU,C,E,K,C,C,M,EAExK,O,E,I,C,I,C,C,E,G,E,EAAA,C,EAAM,MAAM,G,A,M,EACpB,GAAC,AADC,CAAA,EAAM,EAAN,IAAA,EAAA,EACG,EAAE,CAAP,MAAA,C,E,E,CACU,MAAA,C,EAAM,EAAI,IAAI,G,A,M,EAC1B,MADY,EAAN,IAAA,GACA,AAAI,MAAM,CAAC,iBAAiB,EAAE,EAAI,MAAM,CAAC,EAAE,EAAE,KAAA,CAAM,C,M,EAE9C,MAAA,C,EAAM,EAAI,IAAI,G,A,M,EAC3B,GAAI,CAAC,AADC,CAAA,EAAO,EAAP,IAAA,EAAA,EACI,YAAY,EAAI,AAA6B,KAA7B,EAAK,YAAY,CAAC,IAAI,GAE9C,OADA,QAAQ,IAAI,CAAC,CAAC,oBAAoB,EAAE,EAAO,GAAG,EAAE,EAAA,CAAM,EACtD,C,E,E,C,CAEF,MAAA,C,EAAO,EAAK,YAAY,C,A,M,EAIxB,OADA,QAAQ,KAAK,CAAC,yBADP,EAAA,IAAA,IAEP,C,E,E,C,A,M,E,M,C,E,A,C,EAEJ,I,CA8BA,SAAS,aACP,SAAS,cAAc,CAAC,YAAY,KAAK,CAAC,OAAO,CAAG,OACpD,SAAS,cAAc,CAAC,cAAc,KAAK,CAAC,OAAO,CAAG,MACxD,CAEA,SAAS,YACP,SAAS,cAAc,CAAC,YAAY,KAAK,CAAC,OAAO,CAAG,OACpD,SAAS,cAAc,CAAC,cAAc,KAAK,CAAC,OAAO,CAAG,MACxD,CAIA,SAAe,Q,O,oB,W,O,c,I,C,S,C,E,O,E,K,E,K,EACb,MAAA,C,EAAM,aAAa,6CAA8C,CAAE,OAAQ,KAAM,G,A,M,E,OAAjF,EAAA,IAAA,GACA,Y,C,E,A,C,EACF,I,CAEA,SAAS,SACP,QAAQ,GAAG,CAAC,kBACd,CAEA,SAAe,O,O,oB,W,O,c,I,C,S,C,E,O,E,K,E,K,EACb,MAAA,C,EAAM,aAAa,4CAA6C,CAAE,OAAQ,MAAO,G,A,M,E,OAAjF,EAAA,IAAA,GACA,Y,C,E,A,C,EACF,I,CAEA,SAAe,W,O,oB,W,O,c,I,C,S,C,E,O,E,K,E,K,EACb,MAAA,C,EAAM,aAAa,gDAAiD,CAAE,OAAQ,MAAO,G,A,M,E,OAArF,EAAA,IAAA,GACA,Y,C,E,A,C,EACF,I,CAvDA,SAAS,gBAAgB,CAAC,mBAAoB,WAMnC,IAAA,EAAT,WACE,GAAI,CACF,IAAM,EAAU,EAAW,UAAU,CAAC,EAAK,GAC1B,EAAA,iBAAA,EAAQ,GAAG,CAAC,SAAA,CAA7B,EAAoC,MAAA,CAAC,IAAI,EAAE,EAAI,IAAI,CAAC,KAAK,CAAC,CAAC,AAApD,GAAA,GAAA,EAAU,CAAA,CAAA,EAAA,CAAN,EAAM,CAAV,CAAA,EAAA,AACP,CAAA,EAAU,KAAK,CAAC,UAAU,CAAG,CAAC,wBAAwB,EAAE,EAAG,EAAE,EAAE,EAAG,CAAC,CAAC,CACpE,EAAW,KAAK,CAAC,UAAU,CAAG,CAAC,wBAAwB,EAAE,EAAG,EAAE,EAAE,EAAG,CAAC,CAAC,AACvE,CAAE,MAAO,EAAK,CACZ,QAAQ,IAAI,CAAC,4BAA6B,EAC5C,CACF,EAdM,EAAM,SAAS,cAAc,CAAC,OAC9B,EAAY,SAAS,cAAc,CAAC,YACpC,EAAa,SAAS,cAAc,CAAC,cACrC,EAAa,IAAI,WAcvB,EAAI,gBAAgB,CAAC,OAAQ,GAEzB,EAAI,QAAQ,EACd,GAEJ,GAoCA,IAAM,aAAe,W,O,oB,WACb,IAAA,EAkBA,EACA,E,O,c,I,C,S,C,E,O,E,K,E,K,EAlBN,GAAI,CADE,CAAA,EAAgB,aAAa,OAAO,CAAC,gBAArC,EACc,MAAM,AAAI,MAAM,8BAiBxB,MAAA,C,EAAM,MAdN,yCAEI,CACd,OAAQ,OACR,QAAS,CACP,eAAgB,mCAClB,EACA,KAAM,IAAI,gBAAgB,CACxB,WAAY,gBACZ,cAAA,EACA,UAXa,aAAa,OAAO,CAAC,YAYpC,EACF,G,A,M,EAGa,MAAA,C,EAAM,AADb,CAAA,EAAM,EAAN,IAAA,EAAA,EACiB,IAAI,G,A,M,EAE3B,GAFM,EAAO,EAAP,IAAA,GAEF,CAAC,EAAI,EAAE,CAAE,MAAM,AAAI,MAAM,CAAC,sBAAsB,EAAE,KAAK,SAAS,CAAC,GAAA,CAAO,EAM5E,OAJA,aAAa,OAAO,CAAC,eAAgB,EAAK,YAAY,EAClD,EAAK,aAAa,EAAE,aAAa,OAAO,CAAC,gBAAiB,EAAK,aAAa,EAEhF,QAAQ,GAAG,CAAC,0BACZ,C,EAAO,EAAK,YAAY,C,A,C,EAC1B,I,EAIA,SAAe,aAAf,CAAA,EAA4B,OAAA,oBAAA,SAAA,CAAG,E,IAAE,EAAc,EACvC,EAEA,EAiBE,E,E,U,O,c,I,C,S,C,E,O,E,K,E,K,EAjBI,OAHmB,EAAA,EAAA,MAAA,CAAA,GAAA,AAAA,KAAA,IAAA,CAAA,CAAA,EAAA,CAAA,CAAA,CAAA,EAAA,CAAU,CAAC,EAAG,EAAA,CAAA,CAAA,EAAA,MAAA,CAAA,CAAA,GAAA,AAAA,KAAA,IAAA,CAAA,CAAA,EAAA,EAAA,CAAA,CAAA,EAAA,CACvC,EAAc,aAAa,OAAO,CAAC,gBAE7B,C,EAAM,MAAM,EAAK,qBAAA,eAAA,CAAA,EACxB,GADa,CAEhB,QAAS,eAAT,CACE,cAAiB,CAAC,OAAO,EAAE,EAAA,CAAa,CACxC,OAAU,kBACN,EAAA,EAAQ,OAAO,EAAI,CAAC,E,I,A,M,EAIxB,GAAA,CAAA,CAAA,AAAe,MAAf,AATE,CAAA,EAAM,EAAN,IAAA,EAAA,EASE,MAAM,EAAY,CAAA,EAAtB,MAAA,C,E,E,CAGe,OADjB,QAAQ,GAAG,CAAC,uCACK,C,EAAM,e,A,M,EACvB,OADiB,EAAX,IAAA,GACN,C,EAAO,aAAa,EAAK,EAAS,CAAA,GAAQ,A,M,EAGxC,GAAA,CAAA,CAAA,CAAC,EAAI,EAAE,EAAI,AAAe,MAAf,EAAI,MAAM,AAAK,EAA1B,MAAA,C,E,E,CACW,MAAA,C,EAAM,EAAI,IAAI,G,A,M,EAC3B,MADM,EAAO,EAAP,IAAA,GACA,AAAI,MAAM,CAAC,kBAAkB,EAAE,EAAI,MAAM,CAAC,EAAE,EAAE,EAAA,CAAM,C,M,EAG5D,GAAI,AAAe,MAAf,EAAI,MAAM,CAAU,MAAxB,C,EAA+B,K,CAExB,MAAA,C,EAAM,EAAI,IAAI,G,A,M,EAArB,MAAA,C,EAAO,EAAA,IAAA,G,A,C,EACT,GAAA,KAAA,CAAA,IAAA,CAAA,U,CAIA,SAAe,O,O,oB,WACP,IACA,E,O,c,I,C,S,C,E,O,E,K,E,K,EAGF,GAHE,EAAO,AADK,IAAI,gBAAgB,OAAO,QAAQ,CAAC,MAAM,EACrC,GAAG,CAAC,QACb,aAAa,OAAO,CAAC,gBAE/B,CAAA,EAAA,MAAA,C,E,E,A,C,E,K,C,C,M,EAEA,O,E,I,C,I,C,C,E,G,E,EAAA,C,EAAM,SAAS,G,A,M,E,OAAf,EAAA,IAAA,GACA,OAAO,OAAO,CAAC,YAAY,CAAC,CAAC,EAAG,SAAS,KAAK,CAAE,OAAO,QAAQ,CAAC,QAAQ,E,C,E,E,A,M,EAGxE,OADA,QAAQ,KAAK,CAAC,yBADP,EAAA,IAAA,IAEP,C,E,A,M,EAIJ,GAAI,CAAC,aAAa,OAAO,CAAC,gBAGxB,OAFA,QAAQ,GAAG,CAAC,uCACZ,OACA,C,E,C,OAGF,YACA,iB,C,E,A,C,EACF,I,CAKA,SAAe,O,O,oB,WACP,IAAA,EAYF,EAOA,EAEA,EACA,EAIA,E,O,c,I,C,S,C,E,O,E,K,E,K,MApBgB,EAeP,OArBP,EAAuB,SAAC,CAAxB,EACN,IAAM,EAAW,iEAEjB,OAAO,AADQ,OAAO,eAAe,CAAC,IAAI,WAAW,IACvC,MAAM,CAAC,SAAC,CAAA,CAAK,CAA3B,EAAiC,OAAA,EAAM,CAAQ,CAAC,EAAI,EAAS,MAAM,CAAC,AAAE,EAAA,GACxE,EAQM,EAAe,SAAC,CAAhB,EACQ,IAAA,EAAZ,OAAO,KAAK,AAAA,CAAA,EAAA,MAAA,EAAO,YAAY,CAAA,KAAA,CAAnB,EAAoB,qBAAG,IAAI,WAAW,MAC/C,OAAO,CAAC,KAAM,IACd,OAAO,CAAC,MAAO,KACf,OAAO,CAAC,MAAO,IACpB,EAIe,C,GAfO,EAahB,EAAgB,EAAqB,I,oB,WAZnC,IACA,E,O,c,I,C,S,C,EACN,OADM,EAAO,AADG,IAAI,cACC,MAAM,CAAC,GAC5B,C,EAAO,OAAO,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,UAAW,G,A,EAChD,M,A,M,E,OAWM,EAAS,EAAT,IAAA,GACA,EAAgB,EAAa,GAI7B,EAAU,IAAI,IAAI,0CAExB,OAAO,YAAY,CAAC,OAAO,CAAC,gBAAiB,GAC7C,OAAO,YAAY,CAAC,OAAO,CAAC,YAAa,UAYzC,EAAQ,MAAM,CAAG,IAAI,gBATL,CACd,cAAe,OACf,UAAW,SACX,MAVY,wFAWZ,sBAAuB,OACvB,eAAgB,EAChB,aAAc,WAChB,GAE6C,QAAQ,GACrD,OAAO,QAAQ,CAAC,IAAI,CAAG,EAAQ,QAAQ,G,C,E,A,C,EAEvC,I,CAjDA,OAoDA,OAAO,OAAO,CAAG","sources":["<anon>","src/callback.js"],"sourcesContent":["function _array_like_to_array(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _array_with_holes(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _array_without_holes(arr) {\n    if (Array.isArray(arr)) return _array_like_to_array(arr);\n}\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n        var info = gen[key](arg);\n        var value = info.value;\n    } catch (error) {\n        reject(error);\n        return;\n    }\n    if (info.done) {\n        resolve(value);\n    } else {\n        Promise.resolve(value).then(_next, _throw);\n    }\n}\nfunction _async_to_generator(fn) {\n    return function() {\n        var self = this, args = arguments;\n        return new Promise(function(resolve, reject) {\n            var gen = fn.apply(self, args);\n            function _next(value) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n            }\n            function _throw(err) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n            }\n            _next(undefined);\n        });\n    };\n}\nfunction _define_property(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _iterable_to_array(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _iterable_to_array_limit(arr, i) {\n    var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s, _e;\n    try {\n        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _non_iterable_rest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _non_iterable_spread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _object_spread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === \"function\") {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _define_property(target, key, source[key]);\n        });\n    }\n    return target;\n}\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _object_spread_props(target, source) {\n    source = source != null ? source : {};\n    if (Object.getOwnPropertyDescriptors) {\n        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n        ownKeys(Object(source)).forEach(function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n    }\n    return target;\n}\nfunction _sliced_to_array(arr, i) {\n    return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();\n}\nfunction _to_consumable_array(arr) {\n    return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();\n}\nfunction _unsupported_iterable_to_array(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _array_like_to_array(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);\n}\nfunction _ts_generator(thisArg, body) {\n    var f, y, t, _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    }, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n    return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(g && (g = 0, op[0] && (_ = 0)), _)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n}\nvar album_cover;\nvar progress;\nvar duration;\nvar time_left;\nvar last_track_id;\nvar track_id;\nvar track_name;\nvar lyrics;\nvar last_fetched_time;\nvar paused = true;\nvar currently_paused;\nvar urlParams = new URLSearchParams(window.location.search);\nvar code = urlParams.get('code');\nvar clientId = '2ec4eeb99cc94764b7dd30b898d7e3b1';\nvar redirectUri = 'https://james4630.github.io/viewify/';\nif (!clientId) console.warn('clientId not found in localStorage. Make sure auth.js set it before redirect.');\nvar getToken = function(code) {\n    return /*#__PURE__*/ _async_to_generator(function() {\n        var codeVerifier, url, payload, res, response, err;\n        return _ts_generator(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    _state.trys.push([\n                        0,\n                        3,\n                        ,\n                        4\n                    ]);\n                    codeVerifier = localStorage.getItem('code_verifier');\n                    if (!codeVerifier) throw new Error('code_verifier missing from localStorage');\n                    url = \"https://accounts.spotify.com/api/token\";\n                    payload = {\n                        method: 'POST',\n                        headers: {\n                            'Content-Type': 'application/x-www-form-urlencoded',\n                            'Accept': 'application/json'\n                        },\n                        body: new URLSearchParams({\n                            client_id: clientId,\n                            grant_type: 'authorization_code',\n                            code,\n                            redirect_uri: redirectUri,\n                            code_verifier: codeVerifier\n                        })\n                    };\n                    return [\n                        4,\n                        fetch(url, payload)\n                    ];\n                case 1:\n                    res = _state.sent();\n                    return [\n                        4,\n                        res.json()\n                    ];\n                case 2:\n                    response = _state.sent();\n                    console.log('token endpoint response:', response);\n                    if (!res.ok) throw new Error(`Token endpoint returned ${res.status}: ${JSON.stringify(response)}`);\n                    if (!response.access_token) throw new Error(`No access_token in token response: ${JSON.stringify(response)}`);\n                    localStorage.setItem('access_token', response.access_token);\n                    if (response.refresh_token) localStorage.setItem('refresh_token', response.refresh_token);\n                    window.history.replaceState({}, document.title, window.location.pathname);\n                    console.log('Access token saved to localStorage.');\n                    return [\n                        2,\n                        response.access_token\n                    ];\n                case 3:\n                    err = _state.sent();\n                    console.error('getToken error:', err);\n                    // Remove the code from the URL so the page doesn't stay stuck with ?code=...\n                    try {\n                        window.history.replaceState({}, document.title, window.location.pathname);\n                    } catch (e) {\n                        console.warn('Could not clean URL:', e);\n                    }\n                    // If the error is due to a missing code_verifier, restart auth in the same tab\n                    // so a fresh PKCE flow is created. This avoids the user being stuck with an unusable code.\n                    if (err && err.message && err.message.includes('code_verifier')) {\n                        console.warn(\"code_verifier missing \\u2014 restarting auth flow in this tab.\");\n                        try {\n                            auth();\n                        } catch (e) {\n                            console.error('Failed to restart auth:', e);\n                        }\n                        return [\n                            2\n                        ]; // return early — auth() will redirect the user\n                    }\n                    // for other errors, rethrow so upstream can decide\n                    throw err;\n                case 4:\n                    return [\n                        2\n                    ];\n            }\n        });\n    })();\n};\nfunction getCurrentPlayer() {\n    return /*#__PURE__*/ _async_to_generator(function() {\n        return _ts_generator(this, function(_state) {\n            return [\n                2,\n                fetchWrapper('https://api.spotify.com/v1/me/player')\n            ];\n        });\n    })();\n}\n//fetch data\nvar timerID_fetch;\nfunction fetchData() {\n    console.log('fetched data');\n    getCurrentPlayer().then(function(player) {\n        console.log(player);\n        if (player.item) {\n            album_cover = player.item.album.images[0].url;\n            document.getElementById('img').src = album_cover;\n            progress = player.progress_ms;\n            last_fetched_time = Date.now();\n            duration = player.item.duration_ms;\n            time_left = duration - progress;\n            clearTimeout(timerID_fetch);\n            timerID_fetch = setTimeout(fetchData, time_left + 5) //when not reliable: instead of fetching once, fetch every few ms for a second\n            ;\n            last_track_id = player.item.id;\n            track_name = player.item.name;\n            document.getElementById('trackName').innerText = track_name;\n            if (player.actions.disallows.pausing && !paused) {\n                document.getElementById('play').innerHTML = '<span class=\"material-symbols-outlined\">play_arrow</span>';\n                document.getElementById('play').onclick = resume;\n                paused = true;\n            }\n            if (player.actions.disallows.resuming && paused) {\n                document.getElementById('play').innerHTML = '<span class=\"material-symbols-outlined\">pause</span>';\n                document.getElementById('play').onclick = pause;\n                paused = false;\n            }\n            getLyrics(player.item.artists[0].name, track_name, player.item.album.name, Math.floor(duration / 1000)).then(function(syncedLyrics) {\n                if (!syncedLyrics || syncedLyrics.length === 0) {\n                    document.getElementById('lyricsDiv').innerHTML = \"<p>No lyrics available</p>\";\n                    lyrics = [];\n                    return;\n                }\n                //split lyrics into array {time, text}\n                lyrics = syncedLyrics.split(\"\\n\").map(function(line) {\n                    var match = line.match(/\\[(\\d+):(\\d+\\.\\d+)\\]\\s*(.*)/);\n                    if (!match) return null;\n                    var minutes = parseInt(match[1], 10);\n                    var seconds = parseFloat(match[2]);\n                    var time = minutes * 60 + seconds;\n                    return {\n                        time,\n                        text: match[3]\n                    };\n                }).filter(Boolean);\n                //render lyrics\n                var lyricContainer = document.getElementById('lyricsDiv');\n                lyricContainer.innerHTML = '';\n                lyrics.forEach(function(lyric, i) {\n                    var p = document.createElement('p');\n                    p.classList.add(\"line\");\n                    p.textContent = lyric.text || \"\";\n                    lyricContainer.appendChild(p);\n                    lyric.el = p;\n                });\n                lyricContainer.scrollTop = 0;\n                startLyricSync();\n            });\n        } else {\n            document.getElementById('img').src = \"./media/no_track.png\";\n            document.getElementById('trackName').innerText = \"Nothing Playing\";\n        }\n    }).catch(function(err) {\n        return console.error(err);\n    });\n}\nfunction startLyricSync() {\n    setInterval(function() {\n        if (!lyrics || lyrics.length === 0 || paused) return;\n        var timestamp_s = Math.floor((progress + (Date.now() - last_fetched_time)) / 1000);\n        // Find current lyric index\n        var activeIndex = -1;\n        for(var i = 0; i < lyrics.length; i++){\n            if (timestamp_s >= lyrics[i].time) activeIndex = i;\n            else break;\n        }\n        // Update classes\n        lyrics.forEach(function(lyric, i) {\n            lyric.el.classList.remove(\"active\", \"faded\");\n            if (i === activeIndex) lyric.el.classList.add(\"active\");\n            else if (i === activeIndex - 1 || i === activeIndex + 1) lyric.el.classList.add(\"faded\");\n        });\n        // Scroll active line into view\n        if (activeIndex !== -1) {\n            var activeEl = lyrics[activeIndex].el;\n            activeEl.scrollIntoView({\n                behavior: \"smooth\",\n                block: \"center\"\n            });\n        }\n    }, 50);\n}\nfunction checkTimestamp() {\n    return /*#__PURE__*/ _async_to_generator(function() {\n        return _ts_generator(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    return [\n                        4,\n                        getCurrentPlayer().then(function(player) {\n                            track_id = player.item.id;\n                            var _player_actions_disallows_pausing;\n                            currently_paused = (_player_actions_disallows_pausing = player.actions.disallows.pausing) !== null && _player_actions_disallows_pausing !== void 0 ? _player_actions_disallows_pausing : false;\n                        })\n                    ];\n                case 1:\n                    _state.sent();\n                    console.log('checked timestamp');\n                    if (track_id != last_track_id || paused != currently_paused) fetchData();\n                    setTimeout(checkTimestamp, 3000);\n                    return [\n                        2\n                    ];\n            }\n        });\n    })();\n}\nfunction getLyrics(artist, name, album, duration) {\n    return /*#__PURE__*/ _async_to_generator(function() {\n        var url, res, msg, data, error;\n        return _ts_generator(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    url = `https://lrclib.net/api/get?artist_name=${encodeURIComponent(artist)}&track_name=${encodeURIComponent(name)}&album_name=${encodeURIComponent(album)}&duration=${duration}`;\n                    _state.label = 1;\n                case 1:\n                    _state.trys.push([\n                        1,\n                        6,\n                        ,\n                        7\n                    ]);\n                    return [\n                        4,\n                        fetch(url)\n                    ];\n                case 2:\n                    res = _state.sent();\n                    if (!!res.ok) return [\n                        3,\n                        4\n                    ];\n                    return [\n                        4,\n                        res.text()\n                    ];\n                case 3:\n                    msg = _state.sent();\n                    throw new Error(`Lyrics API error ${res.status}: ${text}`);\n                case 4:\n                    return [\n                        4,\n                        res.json()\n                    ];\n                case 5:\n                    data = _state.sent();\n                    if (!data.syncedLyrics || data.syncedLyrics.trim() === \"\") {\n                        console.warn(`No lyrics found for ${artist} - ${name}`);\n                        return [\n                            2,\n                            []\n                        ];\n                    }\n                    return [\n                        2,\n                        data.syncedLyrics\n                    ];\n                case 6:\n                    error = _state.sent();\n                    console.error('Error fetching lyrics:', error);\n                    return [\n                        2,\n                        []\n                    ];\n                case 7:\n                    return [\n                        2\n                    ];\n            }\n        });\n    })();\n}\n//apply gradient when img loads/changes\ndocument.addEventListener(\"DOMContentLoaded\", function() {\n    var applyGradient = function applyGradient() {\n        try {\n            var palette = colorThief.getPalette(img, 2);\n            var _palette_map = _sliced_to_array(palette.map(function(rgb) {\n                return `rgb(${rgb.join(\",\")})`;\n            }), 2), c1 = _palette_map[0], c2 = _palette_map[1];\n            container.style.background = `linear-gradient(135deg, ${c1}, ${c2})`;\n            container2.style.background = `linear-gradient(135deg, ${c1}, ${c2})`;\n        } catch (err) {\n            console.warn(\"Could not extract colors:\", err);\n        }\n    };\n    var img = document.getElementById(\"img\");\n    var container = document.getElementById(\"albumDiv\");\n    var container2 = document.getElementById(\"detailsDiv\");\n    var colorThief = new ColorThief();\n    // update whenever the image finishes loading\n    img.addEventListener(\"load\", applyGradient);\n    if (img.complete) applyGradient();\n});\n//change view\nfunction showLyrics() {\n    document.getElementById('albumDiv').style.display = 'none';\n    document.getElementById('detailsDiv').style.display = 'flex';\n}\nfunction showCover() {\n    document.getElementById('albumDiv').style.display = 'flex';\n    document.getElementById('detailsDiv').style.display = 'none';\n}\n//buttons\nfunction pause() {\n    return /*#__PURE__*/ _async_to_generator(function() {\n        return _ts_generator(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    return [\n                        4,\n                        fetchWrapper('https://api.spotify.com/v1/me/player/pause', {\n                            method: 'PUT'\n                        })\n                    ];\n                case 1:\n                    _state.sent();\n                    fetchData();\n                    return [\n                        2\n                    ];\n            }\n        });\n    })();\n}\nfunction resume() {\n    console.log('tried to resume');\n}\nfunction next() {\n    return /*#__PURE__*/ _async_to_generator(function() {\n        return _ts_generator(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    return [\n                        4,\n                        fetchWrapper('https://api.spotify.com/v1/me/player/next', {\n                            method: 'POST'\n                        })\n                    ];\n                case 1:\n                    _state.sent();\n                    fetchData();\n                    return [\n                        2\n                    ];\n            }\n        });\n    })();\n}\nfunction previous() {\n    return /*#__PURE__*/ _async_to_generator(function() {\n        return _ts_generator(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    return [\n                        4,\n                        fetchWrapper('https://api.spotify.com/v1/me/player/previous', {\n                            method: 'POST'\n                        })\n                    ];\n                case 1:\n                    _state.sent();\n                    fetchData();\n                    return [\n                        2\n                    ];\n            }\n        });\n    })();\n}\n//refresh token\nvar refreshToken = function() {\n    return /*#__PURE__*/ _async_to_generator(function() {\n        var refresh_token, clientId, url, payload, res, data;\n        return _ts_generator(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    refresh_token = localStorage.getItem('refresh_token');\n                    if (!refresh_token) throw new Error('No refresh token available');\n                    clientId = localStorage.getItem('client_id');\n                    url = 'https://accounts.spotify.com/api/token';\n                    payload = {\n                        method: 'POST',\n                        headers: {\n                            'Content-Type': 'application/x-www-form-urlencoded'\n                        },\n                        body: new URLSearchParams({\n                            grant_type: 'refresh_token',\n                            refresh_token,\n                            client_id: clientId\n                        })\n                    };\n                    return [\n                        4,\n                        fetch(url, payload)\n                    ];\n                case 1:\n                    res = _state.sent();\n                    return [\n                        4,\n                        res.json()\n                    ];\n                case 2:\n                    data = _state.sent();\n                    if (!res.ok) throw new Error(`Refresh token failed: ${JSON.stringify(data)}`);\n                    localStorage.setItem('access_token', data.access_token);\n                    if (data.refresh_token) localStorage.setItem('refresh_token', data.refresh_token);\n                    console.log('Access token refreshed');\n                    return [\n                        2,\n                        data.access_token\n                    ];\n            }\n        });\n    })();\n};\n//fetch wrapper for refresh tolken handling\nfunction fetchWrapper(_0) {\n    return /*#__PURE__*/ _async_to_generator(function(url) {\n        var options, retry, accessToken, res, newToken, text1;\n        var _arguments = arguments;\n        return _ts_generator(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    options = _arguments.length > 1 && _arguments[1] !== void 0 ? _arguments[1] : {}, retry = _arguments.length > 2 && _arguments[2] !== void 0 ? _arguments[2] : true;\n                    accessToken = localStorage.getItem('access_token');\n                    return [\n                        4,\n                        fetch(url, _object_spread_props(_object_spread({}, options), {\n                            headers: _object_spread({\n                                'Authorization': `Bearer ${accessToken}`,\n                                'Accept': 'application/json'\n                            }, options.headers || {})\n                        }))\n                    ];\n                case 1:\n                    res = _state.sent();\n                    if (!(res.status === 401 && retry)) return [\n                        3,\n                        3\n                    ];\n                    // Token expired, refresh and retry once\n                    console.log('Access token expired, refreshing...');\n                    return [\n                        4,\n                        refreshToken()\n                    ];\n                case 2:\n                    newToken = _state.sent();\n                    return [\n                        2,\n                        fetchWrapper(url, options, false)\n                    ]; // retry only once\n                case 3:\n                    if (!(!res.ok && res.status !== 204)) return [\n                        3,\n                        5\n                    ];\n                    return [\n                        4,\n                        res.text()\n                    ];\n                case 4:\n                    text1 = _state.sent();\n                    throw new Error(`Spotify API error ${res.status}: ${text1}`);\n                case 5:\n                    if (res.status === 204) return [\n                        2,\n                        null\n                    ];\n                    return [\n                        4,\n                        res.json()\n                    ];\n                case 6:\n                    return [\n                        2,\n                        _state.sent()\n                    ];\n            }\n        });\n    }).apply(this, arguments);\n}\n//init\nfunction init() {\n    return /*#__PURE__*/ _async_to_generator(function() {\n        var urlParams, code, token, err;\n        return _ts_generator(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    urlParams = new URLSearchParams(window.location.search);\n                    code = urlParams.get('code');\n                    token = localStorage.getItem('access_token');\n                    if (!code) return [\n                        3,\n                        4\n                    ];\n                    _state.label = 1;\n                case 1:\n                    _state.trys.push([\n                        1,\n                        3,\n                        ,\n                        4\n                    ]);\n                    return [\n                        4,\n                        getToken(code)\n                    ];\n                case 2:\n                    _state.sent();\n                    window.history.replaceState({}, document.title, window.location.pathname);\n                    return [\n                        3,\n                        4\n                    ];\n                case 3:\n                    err = _state.sent();\n                    console.error('Token exchange failed:', err);\n                    return [\n                        2\n                    ];\n                case 4:\n                    if (!localStorage.getItem('access_token')) {\n                        console.log(\"No token found, starting auth flow\\u2026\");\n                        auth();\n                        return [\n                            2\n                        ];\n                    }\n                    fetchData();\n                    checkTimestamp();\n                    return [\n                        2\n                    ];\n            }\n        });\n    })();\n}\ninit();\n//first auth\nfunction auth() {\n    return /*#__PURE__*/ _async_to_generator(function() {\n        var generateRandomString, sha256, base64encode, codeVerifier, hashed, codeChallenge, scope, authUrl, params;\n        return _ts_generator(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    generateRandomString = function(length) {\n                        var possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n                        var values = crypto.getRandomValues(new Uint8Array(length));\n                        return values.reduce(function(acc, x) {\n                            return acc + possible[x % possible.length];\n                        }, \"\");\n                    };\n                    sha256 = function(plain) {\n                        return /*#__PURE__*/ _async_to_generator(function() {\n                            var encoder, data;\n                            return _ts_generator(this, function(_state) {\n                                encoder = new TextEncoder();\n                                data = encoder.encode(plain);\n                                return [\n                                    2,\n                                    window.crypto.subtle.digest('SHA-256', data)\n                                ];\n                            });\n                        })();\n                    };\n                    base64encode = function(input) {\n                        var _String;\n                        return btoa((_String = String).fromCharCode.apply(_String, _to_consumable_array(new Uint8Array(input)))).replace(/=/g, '').replace(/\\+/g, '-').replace(/\\//g, '_');\n                    };\n                    codeVerifier = generateRandomString(64);\n                    return [\n                        4,\n                        sha256(codeVerifier)\n                    ];\n                case 1:\n                    hashed = _state.sent();\n                    codeChallenge = base64encode(hashed);\n                    scope = 'user-read-private user-read-email user-read-playback-state user-modify-playback-state';\n                    authUrl = new URL(\"https://accounts.spotify.com/authorize\");\n                    window.localStorage.setItem('code_verifier', codeVerifier);\n                    window.localStorage.setItem('client_id', clientId);\n                    params = {\n                        response_type: 'code',\n                        client_id: clientId,\n                        scope,\n                        code_challenge_method: 'S256',\n                        code_challenge: codeChallenge,\n                        redirect_uri: redirectUri\n                    };\n                    authUrl.search = new URLSearchParams(params).toString();\n                    window.location.href = authUrl.toString();\n                    return [\n                        2\n                    ];\n            }\n        });\n    })();\n}\n//debug\nwindow.runAuth = auth;\n\n//# sourceMappingURL=viewify.d3a35e12.js.map\n","let album_cover;\nlet progress;\nlet duration;\nlet time_left;\nlet last_track_id;\nlet track_id;\nlet track_name;\nlet lyrics;\nlet last_fetched_time;\nlet paused = true;\nlet currently_paused;\n\nconst urlParams = new URLSearchParams(window.location.search);\nconst code = urlParams.get('code');\n\nconst clientId = '2ec4eeb99cc94764b7dd30b898d7e3b1';\nconst redirectUri = 'https://james4630.github.io/viewify/';\n\nif (!clientId) {\n  console.warn('clientId not found in localStorage. Make sure auth.js set it before redirect.');\n}\n\nconst getToken = async (code) => {\n  try {\n    const codeVerifier = localStorage.getItem('code_verifier');\n    if (!codeVerifier) throw new Error('code_verifier missing from localStorage');\n\n    const url = \"https://accounts.spotify.com/api/token\";\n    const payload = {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n        'Accept': 'application/json'\n      },\n      body: new URLSearchParams({\n        client_id: clientId,\n        grant_type: 'authorization_code',\n        code,\n        redirect_uri: redirectUri,\n        code_verifier: codeVerifier,\n      }),\n    };\n\n    const res = await fetch(url, payload);\n    const response = await res.json();\n    console.log('token endpoint response:', response);\n\n    if (!res.ok) {\n      throw new Error(`Token endpoint returned ${res.status}: ${JSON.stringify(response)}`);\n    }\n\n    if (!response.access_token) {\n      throw new Error(`No access_token in token response: ${JSON.stringify(response)}`);\n    }\n\n    localStorage.setItem('access_token', response.access_token);\n    if (response.refresh_token) localStorage.setItem('refresh_token', response.refresh_token);\n\n    window.history.replaceState({}, document.title, window.location.pathname);\n\n    console.log('Access token saved to localStorage.');\n    return response.access_token;\n  } catch (err) {\n    console.error('getToken error:', err);\n\n    // Remove the code from the URL so the page doesn't stay stuck with ?code=...\n    try {\n      window.history.replaceState({}, document.title, window.location.pathname);\n    } catch (e) {\n      console.warn('Could not clean URL:', e);\n    }\n\n    // If the error is due to a missing code_verifier, restart auth in the same tab\n    // so a fresh PKCE flow is created. This avoids the user being stuck with an unusable code.\n    if (err && err.message && err.message.includes('code_verifier')) {\n      console.warn('code_verifier missing — restarting auth flow in this tab.');\n      try { auth(); } catch (e) { console.error('Failed to restart auth:', e); }\n      return; // return early — auth() will redirect the user\n    }\n\n    // for other errors, rethrow so upstream can decide\n    throw err;\n  }\n};\n\nasync function getCurrentPlayer() {\n  return fetchWrapper('https://api.spotify.com/v1/me/player');\n}\n\n\n//fetch data\nlet timerID_fetch;\nfunction fetchData(){\n    console.log('fetched data')\n    getCurrentPlayer()\n      .then(player => {\n        console.log(player)\n        if (player.item) {\n\n        album_cover = player.item.album.images[0].url\n        document.getElementById('img').src = album_cover\n    \n        progress = player.progress_ms\n        last_fetched_time = Date.now();\n        duration = player.item.duration_ms\n        time_left = duration - progress\n        clearTimeout(timerID_fetch)\n        timerID_fetch = setTimeout(fetchData,time_left+5) //when not reliable: instead of fetching once, fetch every few ms for a second\n\n        last_track_id = player.item.id\n\n        track_name = player.item.name\n        document.getElementById('trackName').innerText = track_name\n\n        if (player.actions.disallows.pausing && !paused) {\n          document.getElementById('play').innerHTML = '<span class=\"material-symbols-outlined\">play_arrow</span>'\n          document.getElementById('play').onclick = resume;\n          paused = true\n        }\n        if (player.actions.disallows.resuming && paused) {\n          document.getElementById('play').innerHTML = '<span class=\"material-symbols-outlined\">pause</span>'\n          document.getElementById('play').onclick = pause;\n          paused = false\n        }\n\n        getLyrics(player.item.artists[0].name, track_name, player.item.album.name, Math.floor(duration/1000))\n          .then (syncedLyrics => {\n\n            if (!syncedLyrics || syncedLyrics.length === 0) {\n              document.getElementById('lyricsDiv').innerHTML = \"<p>No lyrics available</p>\";\n              lyrics = [];\n              return;\n            }\n\n            //split lyrics into array {time, text}\n            lyrics = syncedLyrics.split(\"\\n\").map(line => {\n              const match = line.match(/\\[(\\d+):(\\d+\\.\\d+)\\]\\s*(.*)/);\n              if (!match) return null;\n              const minutes = parseInt(match[1], 10)\n              const seconds = parseFloat(match[2])\n              const time = minutes * 60 + seconds\n              return { time, text: match[3] };\n            }).filter(Boolean);\n\n            //render lyrics\n            const lyricContainer = document.getElementById('lyricsDiv');\n            lyricContainer.innerHTML = ''\n            lyrics.forEach((lyric, i) => {\n              const p = document.createElement('p')\n              p.classList.add(\"line\")\n              p.textContent = lyric.text || \"\";\n              lyricContainer.appendChild(p)\n              lyric.el = p;\n            })\n            lyricContainer.scrollTop = 0\n            startLyricSync();\n\n          })\n        } else {\n          document.getElementById('img').src = \"./media/no_track.png\"\n          document.getElementById('trackName').innerText = \"Nothing Playing\"\n        }\n      })\n      .catch(err => console.error(err));\n}\n\n\nfunction startLyricSync() {\n  setInterval(() => {\n    if (!lyrics || lyrics.length === 0 || paused) return;\n\n    const timestamp_s = Math.floor((progress + (Date.now() - last_fetched_time))/1000)\n\n    // Find current lyric index\n    let activeIndex = -1;\n    for (let i = 0; i < lyrics.length; i++) {\n      if (timestamp_s >= lyrics[i].time) {\n        activeIndex = i;\n      } else {\n        break;\n      }\n    }\n\n    // Update classes\nlyrics.forEach((lyric, i) => {\n  lyric.el.classList.remove(\"active\", \"faded\");\n\n  if (i === activeIndex) {\n    lyric.el.classList.add(\"active\");\n  } else if (i === activeIndex - 1 || i === activeIndex + 1) {\n    lyric.el.classList.add(\"faded\");\n  }\n});\n\n    // Scroll active line into view\n    if (activeIndex !== -1) {\n      const activeEl = lyrics[activeIndex].el;\n      activeEl.scrollIntoView({\n        behavior: \"smooth\",\n        block: \"center\"\n      });\n    }\n  }, 50);\n}\n\n\nasync function checkTimestamp() {\n    await getCurrentPlayer().then(player => {\n        track_id = player.item.id\n        currently_paused = player.actions.disallows.pausing ?? false\n    })\n    console.log('checked timestamp')\n    if (track_id != last_track_id || paused != currently_paused) {\n        fetchData();\n    }\n    setTimeout(checkTimestamp,3000)\n}\n\nasync function getLyrics(artist, name, album, duration) {\n  const url = `https://lrclib.net/api/get?artist_name=${encodeURIComponent(artist)}&track_name=${encodeURIComponent(name)}&album_name=${encodeURIComponent(album)}&duration=${duration}`\n  try {\n    const res = await fetch(url)\n    if (!res.ok) {\n      const msg = await res.text()\n      throw new Error(`Lyrics API error ${res.status}: ${text}`)\n    }\n    const data = await res.json();\n    if (!data.syncedLyrics || data.syncedLyrics.trim() === \"\") {\n      console.warn(`No lyrics found for ${artist} - ${name}`);\n      return [];\n    }\n    return data.syncedLyrics;\n\n  } catch (error) {\n    console.error('Error fetching lyrics:', error);\n    return [];\n  }\n}\n\n\n//apply gradient when img loads/changes\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  const img = document.getElementById(\"img\");\n  const container = document.getElementById(\"albumDiv\");\n  const container2 = document.getElementById(\"detailsDiv\");\n  const colorThief = new ColorThief();\n\n  function applyGradient() {\n    try {\n      const palette = colorThief.getPalette(img, 2);\n      const [c1, c2] = palette.map(rgb => `rgb(${rgb.join(\",\")})`);\n      container.style.background = `linear-gradient(135deg, ${c1}, ${c2})`;\n      container2.style.background = `linear-gradient(135deg, ${c1}, ${c2})`;\n    } catch (err) {\n      console.warn(\"Could not extract colors:\", err);\n    }\n  }\n\n  // update whenever the image finishes loading\n  img.addEventListener(\"load\", applyGradient);\n\n  if (img.complete) {\n    applyGradient();\n  }\n});\n\n//change view\nfunction showLyrics() {\n  document.getElementById('albumDiv').style.display = 'none'\n  document.getElementById('detailsDiv').style.display = 'flex'\n}\n\nfunction showCover() {\n  document.getElementById('albumDiv').style.display = 'flex'\n  document.getElementById('detailsDiv').style.display = 'none'\n}\n\n\n//buttons\nasync function pause() {\n  await fetchWrapper('https://api.spotify.com/v1/me/player/pause', { method: 'PUT' })\n  fetchData();\n}\n\nfunction resume() {\n  console.log('tried to resume')\n}\n\nasync function next() {\n  await fetchWrapper('https://api.spotify.com/v1/me/player/next', { method: 'POST' });\n  fetchData();\n}\n\nasync function previous() {\n  await fetchWrapper('https://api.spotify.com/v1/me/player/previous', { method: 'POST' });\n  fetchData();\n}\n\n\n//refresh token\nconst refreshToken = async () => {\n  const refresh_token = localStorage.getItem('refresh_token');\n  if (!refresh_token) throw new Error('No refresh token available');\n\n  const clientId = localStorage.getItem('client_id');\n  const url = 'https://accounts.spotify.com/api/token';\n\n  const payload = {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded',\n    },\n    body: new URLSearchParams({\n      grant_type: 'refresh_token',\n      refresh_token,\n      client_id: clientId,\n    }),\n  };\n\n  const res = await fetch(url, payload);\n  const data = await res.json();\n\n  if (!res.ok) throw new Error(`Refresh token failed: ${JSON.stringify(data)}`);\n\n  localStorage.setItem('access_token', data.access_token);\n  if (data.refresh_token) localStorage.setItem('refresh_token', data.refresh_token);\n\n  console.log('Access token refreshed');\n  return data.access_token;\n};\n\n\n//fetch wrapper for refresh tolken handling\nasync function fetchWrapper(url, options = {}, retry = true) {\n  const accessToken = localStorage.getItem('access_token');\n\n  const res = await fetch(url, {\n    ...options,\n    headers: {\n      'Authorization': `Bearer ${accessToken}`,\n      'Accept': 'application/json',\n      ...(options.headers || {}),\n    }\n  });\n\n  if (res.status === 401 && retry) {\n    // Token expired, refresh and retry once\n    console.log('Access token expired, refreshing...');\n    const newToken = await refreshToken();\n    return fetchWrapper(url, options, false); // retry only once\n  }\n\n  if (!res.ok && res.status !== 204) {\n    const text = await res.text();\n    throw new Error(`Spotify API error ${res.status}: ${text}`);\n  }\n\n  if (res.status === 204) return null;\n\n  return await res.json();\n}\n\n\n//init\nasync function init() {\n  const urlParams = new URLSearchParams(window.location.search);\n  const code = urlParams.get('code');\n  const token = localStorage.getItem('access_token');\n\n  if (code) {\n    try {\n      await getToken(code);\n      window.history.replaceState({}, document.title, window.location.pathname);\n    } catch (err) {\n      console.error('Token exchange failed:', err);\n      return;\n    }\n  }\n\n  if (!localStorage.getItem('access_token')) {\n    console.log(\"No token found, starting auth flow…\");\n    auth();\n    return;\n  }\n\n  fetchData();\n  checkTimestamp();\n}\ninit();\n\n\n//first auth\nasync function auth() {\n  const generateRandomString = (length) => {\n  const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n  const values = crypto.getRandomValues(new Uint8Array(length));\n  return values.reduce((acc, x) => acc + possible[x % possible.length], \"\");\n}\n\nconst sha256 = async (plain) => {\n  const encoder = new TextEncoder()\n  const data = encoder.encode(plain)\n  return window.crypto.subtle.digest('SHA-256', data)\n}\n\nconst base64encode = (input) => {\n  return btoa(String.fromCharCode(...new Uint8Array(input)))\n    .replace(/=/g, '')\n    .replace(/\\+/g, '-')\n    .replace(/\\//g, '_');\n}\n\nconst codeVerifier  = generateRandomString(64);\n\nconst hashed = await sha256(codeVerifier)\nconst codeChallenge = base64encode(hashed);\n\n\nconst scope = 'user-read-private user-read-email user-read-playback-state user-modify-playback-state';\nconst authUrl = new URL(\"https://accounts.spotify.com/authorize\")\n\nwindow.localStorage.setItem('code_verifier', codeVerifier);\nwindow.localStorage.setItem('client_id', clientId);\n\n\nconst params =  {\n  response_type: 'code',\n  client_id: clientId,\n  scope,\n  code_challenge_method: 'S256',\n  code_challenge: codeChallenge,\n  redirect_uri: redirectUri,\n}\n\nauthUrl.search = new URLSearchParams(params).toString();\nwindow.location.href = authUrl.toString();\n\n}\n\n//debug\nwindow.runAuth = auth;"],"names":["_array_like_to_array","arr","len","length","i","arr2","Array","_array_with_holes","isArray","_array_without_holes","asyncGeneratorStep","gen","resolve","reject","_next","_throw","key","arg","info","value","error","done","Promise","then","_async_to_generator","fn","self","args","arguments","apply","err","undefined","_define_property","obj","Object","defineProperty","enumerable","configurable","writable","_iterable_to_array","iter","Symbol","iterator","from","_iterable_to_array_limit","_s","_e","_i","_arr","_n","_d","call","next","push","_non_iterable_rest","TypeError","_non_iterable_spread","_object_spread","target","source","ownKeys","keys","getOwnPropertySymbols","concat","filter","sym","getOwnPropertyDescriptor","forEach","object","enumerableOnly","symbols","_object_spread_props","getOwnPropertyDescriptors","defineProperties","_sliced_to_array","_unsupported_iterable_to_array","_to_consumable_array","o","minLen","n","prototype","toString","slice","name","test","_ts_generator","thisArg","body","f","y","t","_","label","sent","trys","ops","g","create","Iterator","verb","v","op","pop","e","album_cover","progress","duration","time_left","last_track_id","track_id","track_name","lyrics","last_fetched_time","currently_paused","timerID_fetch","paused","urlParams","URLSearchParams","window","location","search","code","get","clientId","redirectUri","console","warn","getToken","codeVerifier","res","response","_state","localStorage","getItem","Error","fetch","method","headers","client_id","grant_type","redirect_uri","code_verifier","json","log","ok","status","JSON","stringify","access_token","setItem","refresh_token","history","replaceState","document","title","pathname","message","includes","auth","getCurrentPlayer","fetchWrapper","fetchData","player","item","album","images","url","getElementById","src","progress_ms","Date","now","duration_ms","clearTimeout","setTimeout","id","innerText","actions","disallows","pausing","innerHTML","onclick","resume","resuming","pause","getLyrics","artists","Math","floor","syncedLyrics","split","map","line","match","time","minutes","parseInt","parseFloat","text","Boolean","lyricContainer","lyric","p","createElement","classList","add","textContent","appendChild","el","scrollTop","startLyricSync","catch","setInterval","timestamp_s","activeIndex","remove","activeEl","scrollIntoView","behavior","block","checkTimestamp","_player_actions_disallows_pausing","artist","data","encodeURIComponent","trim","showLyrics","style","display","showCover","previous","addEventListener","applyGradient","palette","colorThief","getPalette","img","_palette_map","rgb","join","c1","c2","container","background","container2","ColorThief","complete","refreshToken","_0","options","retry","accessToken","text1","_arguments","init","generateRandomString","base64encode","hashed","codeChallenge","authUrl","plain","possible","values","crypto","getRandomValues","Uint8Array","reduce","acc","x","input","_String","btoa","String","fromCharCode","replace","encoder","TextEncoder","encode","subtle","digest","URL","response_type","scope","code_challenge_method","code_challenge","href","runAuth"],"version":3,"file":"viewify.d3a35e12.js.map"}